{"version":3,"sources":["webpack:///./public/app/plugins/datasource/opentsdb/datasource.ts","webpack:///./public/app/plugins/datasource/opentsdb/query_ctrl.ts","webpack:///./public/app/plugins/datasource/opentsdb/components/OpenTsdbDetails.tsx","webpack:///./public/app/plugins/datasource/opentsdb/module.ts","webpack:///./public/app/plugins/datasource/opentsdb/components/ConfigEditor.tsx"],"names":["OpenTsDatasource","instanceSettings","templateSrv","type","url","name","withCredentials","basicAuth","jsonData","tsdbVersion","tsdbResolution","lookupLimit","tagKeys","aggregatorsPromise","filterTypesPromise","options","start","this","convertToTSDBTime","rangeRaw","from","timezone","end","to","qs","_","each","targets","target","metric","push","convertTargetToQuery","queries","compact","isEmpty","Promise","resolve","data","groupByTags","query","filters","length","val","tagk","tags","key","filter","hide","performTimeSeriesQuery","then","response","metricToTargetMapping","mapMetricsToTargets","map","metricData","index","_saveTagKeys","transformMetricData","eventList","aggregator","annotation","results","annotationObject","annotations","isGlobal","globalAnnotations","event","text","description","time","Math","floor","startTime","i","variableExists","Object","keys","tagKey","msResolution","reqBody","showQuery","method","_addCredentialOptions","getBackendSrv","datasourceRequest","aggregateTags","tag","_get","q","max","result","keysArray","split","trim","keysQuery","splice","join","m","limit","tagvs","r","indexOf","tagks","tagv","relativeUrl","params","headers","Authorization","interpolated","replace","err","reject","responseTransform","value","metricsQuery","match","_performSuggestQuery","tagNamesQuery","_performMetricKeyLookup","tagValuesQuery","_performMetricKeyValueLookup","tagNamesSuggestQuery","tagValuesSuggestQuery","status","message","isArray","sort","md","metricLabel","createMetricLabel","dps","v","k","datapoints","alias","scopedVars","clone","label","tagData","toPairs","has","shouldComputeRate","rate","rateOptions","counter","isCounter","counterMax","parseInt","counterResetValue","resetValue","dropResets","ResetValue","disableDownsampling","interval","downsampleInterval","parseFloat","downsample","downsampleAggregator","downsampleFillPolicy","angular","copy","filterKey","explicitTags","metrics","interpolatedTagValue","arrTagV","findIndex","every","tagV","tagK","includes","date","roundUp","dateMath","parse","valueOf","DataSourceApi","OpenTsQueryCtrl","$scope","$injector","errors","validateTarget","aggregators","fillPolicies","filterTypes","datasource","getAggregators","aggs","getFilterTypes","suggestMetrics","callback","metricFindQuery","getTextValues","suggestTagKeys","suggestTagValues","refresh","metricFindResult","addTagMode","currentTagKey","currentTagValue","targetBlur","removeTag","addTag","size","addFilterMode","currentFilterType","currentFilterGroupBy","currentFilter","currentFilterKey","currentFilterValue","groupBy","fil","removeFilter","addFilter","errs","shouldDownsample","kbn","describe_interval","QueryCtrl","templateUrl","tsdbVersions","tsdbResolutions","OpenTsdbDetails","props","onChange","className","width","find","version","onSelectChangeHandler","resolution","onInputChangeHandler","newValue","currentTarget","AnnotationsQueryCtrl","plugin","DataSourcePlugin","setQueryCtrl","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","setAnnotationQueryCtrl"],"mappings":"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","file":"opentsdbPlugin.5c3edd1990e1c7cf41f1.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\nimport { dateMath, DataQueryRequest, DataSourceApi } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { OpenTsdbOptions, OpenTsdbQuery } from './types';\n\nexport default class OpenTsDatasource extends DataSourceApi<OpenTsdbQuery, OpenTsdbOptions> {\n  type: any;\n  url: any;\n  name: any;\n  withCredentials: any;\n  basicAuth: any;\n  tsdbVersion: any;\n  tsdbResolution: any;\n  lookupLimit: any;\n  tagKeys: any;\n\n  aggregatorsPromise: any;\n  filterTypesPromise: any;\n\n  /** @ngInject */\n  constructor(instanceSettings: any, private templateSrv: TemplateSrv) {\n    super(instanceSettings);\n    this.type = 'opentsdb';\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\n    this.lookupLimit = instanceSettings.jsonData.lookupLimit || 1000;\n    this.tagKeys = {};\n\n    this.aggregatorsPromise = null;\n    this.filterTypesPromise = null;\n  }\n\n  // Called once per panel (graph)\n  query(options: DataQueryRequest) {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs: any[] = [];\n\n    _.each(options.targets, target => {\n      if (!target.metric) {\n        return;\n      }\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\n    });\n\n    const queries = _.compact(qs);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (_.isEmpty(queries)) {\n      return Promise.resolve({ data: [] });\n    }\n\n    const groupByTags: any = {};\n    _.each(queries, query => {\n      if (query.filters && query.filters.length > 0) {\n        _.each(query.filters, val => {\n          groupByTags[val.tagk] = true;\n        });\n      } else {\n        _.each(query.tags, (val, key) => {\n          groupByTags[key] = true;\n        });\n      }\n    });\n\n    options.targets = _.filter(options.targets, query => {\n      return query.hide !== true;\n    });\n\n    return this.performTimeSeriesQuery(queries, start, end).then((response: any) => {\n      const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\n      const result = _.map(response.data, (metricData: any, index: number) => {\n        index = metricToTargetMapping[index];\n        if (index === -1) {\n          index = 0;\n        }\n        this._saveTagKeys(metricData);\n\n        return this.transformMetricData(metricData, groupByTags, options.targets[index], options, this.tsdbResolution);\n      });\n      return { data: result };\n    });\n  }\n\n  annotationQuery(options: any) {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs = [];\n    const eventList: any[] = [];\n\n    qs.push({ aggregator: 'sum', metric: options.annotation.target });\n\n    const queries = _.compact(qs);\n\n    return this.performTimeSeriesQuery(queries, start, end).then((results: any) => {\n      if (results.data[0]) {\n        let annotationObject = results.data[0].annotations;\n        if (options.annotation.isGlobal) {\n          annotationObject = results.data[0].globalAnnotations;\n        }\n        if (annotationObject) {\n          _.each(annotationObject, annotation => {\n            const event = {\n              text: annotation.description,\n              time: Math.floor(annotation.startTime) * 1000,\n              annotation: options.annotation,\n            };\n\n            eventList.push(event);\n          });\n        }\n      }\n      return eventList;\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    if (target.filters && target.filters.length > 0) {\n      for (let i = 0; i < target.filters.length; i++) {\n        if (this.templateSrv.variableExists(target.filters[i].filter)) {\n          return true;\n        }\n      }\n    }\n\n    if (target.tags && Object.keys(target.tags).length > 0) {\n      for (const tagKey in target.tags) {\n        if (this.templateSrv.variableExists(target.tags[tagKey])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  performTimeSeriesQuery(queries: any[], start: any, end: any) {\n    let msResolution = false;\n    if (this.tsdbResolution === 2) {\n      msResolution = true;\n    }\n    const reqBody: any = {\n      start: start,\n      queries: queries,\n      msResolution: msResolution,\n      globalAnnotations: true,\n    };\n    if (this.tsdbVersion === 3) {\n      reqBody.showQuery = true;\n    }\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (end) {\n      reqBody.end = end;\n    }\n\n    const options = {\n      method: 'POST',\n      url: this.url + '/api/query',\n      data: reqBody,\n    };\n\n    this._addCredentialOptions(options);\n    return getBackendSrv().datasourceRequest(options);\n  }\n\n  suggestTagKeys(metric: string | number) {\n    return Promise.resolve(this.tagKeys[metric] || []);\n  }\n\n  _saveTagKeys(metricData: { tags: {}; aggregateTags: any; metric: string | number }) {\n    const tagKeys = Object.keys(metricData.tags);\n    _.each(metricData.aggregateTags, tag => {\n      tagKeys.push(tag);\n    });\n\n    this.tagKeys[metricData.metric] = tagKeys;\n  }\n\n  _performSuggestQuery(query: string, type: string) {\n    return this._get('/api/suggest', { type, q: query, max: this.lookupLimit }).then((result: any) => {\n      return result.data;\n    });\n  }\n\n  _performMetricKeyValueLookup(metric: string, keys: any) {\n    if (!metric || !keys) {\n      return Promise.resolve([]);\n    }\n\n    const keysArray = keys.split(',').map((key: any) => {\n      return key.trim();\n    });\n    const key = keysArray[0];\n    let keysQuery = key + '=*';\n\n    if (keysArray.length > 1) {\n      keysQuery += ',' + keysArray.splice(1).join(',');\n    }\n\n    const m = metric + '{' + keysQuery + '}';\n\n    return this._get('/api/search/lookup', { m: m, limit: this.lookupLimit }).then((result: any) => {\n      result = result.data.results;\n      const tagvs: any[] = [];\n      _.each(result, r => {\n        if (tagvs.indexOf(r.tags[key]) === -1) {\n          tagvs.push(r.tags[key]);\n        }\n      });\n      return tagvs;\n    });\n  }\n\n  _performMetricKeyLookup(metric: any) {\n    if (!metric) {\n      return Promise.resolve([]);\n    }\n\n    return this._get('/api/search/lookup', { m: metric, limit: 1000 }).then((result: any) => {\n      result = result.data.results;\n      const tagks: any[] = [];\n      _.each(result, r => {\n        _.each(r.tags, (tagv, tagk) => {\n          if (tagks.indexOf(tagk) === -1) {\n            tagks.push(tagk);\n          }\n        });\n      });\n      return tagks;\n    });\n  }\n\n  _get(relativeUrl: string, params?: { type?: string; q?: string; max?: number; m?: any; limit?: number }) {\n    const options = {\n      method: 'GET',\n      url: this.url + relativeUrl,\n      params: params,\n    };\n\n    this._addCredentialOptions(options);\n\n    return getBackendSrv().datasourceRequest(options);\n  }\n\n  _addCredentialOptions(options: any) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = { Authorization: this.basicAuth };\n    }\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    let interpolated;\n    try {\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    const responseTransform = (result: any) => {\n      return _.map(result, value => {\n        return { text: value };\n      });\n    };\n\n    const metricsRegex = /metrics\\((.*)\\)/;\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\n\n    const metricsQuery = interpolated.match(metricsRegex);\n    if (metricsQuery) {\n      return this._performSuggestQuery(metricsQuery[1], 'metrics').then(responseTransform);\n    }\n\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\n    if (tagNamesQuery) {\n      return this._performMetricKeyLookup(tagNamesQuery[1]).then(responseTransform);\n    }\n\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\n    if (tagValuesQuery) {\n      return this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2]).then(responseTransform);\n    }\n\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\n    if (tagNamesSuggestQuery) {\n      return this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').then(responseTransform);\n    }\n\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\n    if (tagValuesSuggestQuery) {\n      return this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').then(responseTransform);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  testDatasource() {\n    return this._performSuggestQuery('cpu', 'metrics').then(() => {\n      return { status: 'success', message: 'Data source is working' };\n    });\n  }\n\n  getAggregators() {\n    if (this.aggregatorsPromise) {\n      return this.aggregatorsPromise;\n    }\n\n    this.aggregatorsPromise = this._get('/api/aggregators').then((result: any) => {\n      if (result.data && _.isArray(result.data)) {\n        return result.data.sort();\n      }\n      return [];\n    });\n    return this.aggregatorsPromise;\n  }\n\n  getFilterTypes() {\n    if (this.filterTypesPromise) {\n      return this.filterTypesPromise;\n    }\n\n    this.filterTypesPromise = this._get('/api/config/filters').then((result: any) => {\n      if (result.data) {\n        return Object.keys(result.data).sort();\n      }\n      return [];\n    });\n    return this.filterTypesPromise;\n  }\n\n  transformMetricData(md: { dps: any }, groupByTags: any, target: any, options: any, tsdbResolution: number) {\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\n    const dps: any[] = [];\n\n    // TSDB returns datapoints has a hash of ts => value.\n    // Can't use _.pairs(invert()) because it stringifies keys/values\n    _.each(md.dps, (v: any, k: number) => {\n      if (tsdbResolution === 2) {\n        dps.push([v, k * 1]);\n      } else {\n        dps.push([v, k * 1000]);\n      }\n    });\n\n    return { target: metricLabel, datapoints: dps };\n  }\n\n  createMetricLabel(\n    md: { dps?: any; tags?: any; metric?: any },\n    target: { alias: string },\n    groupByTags: any,\n    options: { scopedVars: any }\n  ) {\n    if (target.alias) {\n      const scopedVars = _.clone(options.scopedVars || {});\n      _.each(md.tags, (value, key) => {\n        scopedVars['tag_' + key] = { value: value };\n      });\n      return this.templateSrv.replace(target.alias, scopedVars);\n    }\n\n    let label = md.metric;\n    const tagData: any[] = [];\n\n    if (!_.isEmpty(md.tags)) {\n      _.each(_.toPairs(md.tags), tag => {\n        if (_.has(groupByTags, tag[0])) {\n          tagData.push(tag[0] + '=' + tag[1]);\n        }\n      });\n    }\n\n    if (!_.isEmpty(tagData)) {\n      label += '{' + tagData.join(', ') + '}';\n    }\n\n    return label;\n  }\n\n  convertTargetToQuery(target: any, options: any, tsdbVersion: number) {\n    if (!target.metric || target.hide) {\n      return null;\n    }\n\n    const query: any = {\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\n      aggregator: 'avg',\n    };\n\n    if (target.aggregator) {\n      query.aggregator = this.templateSrv.replace(target.aggregator);\n    }\n\n    if (target.shouldComputeRate) {\n      query.rate = true;\n      query.rateOptions = {\n        counter: !!target.isCounter,\n      };\n\n      if (target.counterMax && target.counterMax.length) {\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\n      }\n\n      if (target.counterResetValue && target.counterResetValue.length) {\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\n      }\n\n      if (tsdbVersion >= 2) {\n        query.rateOptions.dropResets =\n          !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\n      }\n    }\n\n    if (!target.disableDownsampling) {\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\n\n      if (interval.match(/\\.[0-9]+s/)) {\n        interval = parseFloat(interval) * 1000 + 'ms';\n      }\n\n      query.downsample = interval + '-' + target.downsampleAggregator;\n\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\n        query.downsample += '-' + target.downsampleFillPolicy;\n      }\n    }\n\n    if (target.filters && target.filters.length > 0) {\n      query.filters = angular.copy(target.filters);\n      if (query.filters) {\n        for (const filterKey in query.filters) {\n          query.filters[filterKey].filter = this.templateSrv.replace(\n            query.filters[filterKey].filter,\n            options.scopedVars,\n            'pipe'\n          );\n        }\n      }\n    } else {\n      query.tags = angular.copy(target.tags);\n      if (query.tags) {\n        for (const tagKey in query.tags) {\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\n        }\n      }\n    }\n\n    if (target.explicitTags) {\n      query.explicitTags = true;\n    }\n\n    return query;\n  }\n\n  mapMetricsToTargets(metrics: any, options: any, tsdbVersion: number) {\n    let interpolatedTagValue, arrTagV;\n    return _.map(metrics, metricData => {\n      if (tsdbVersion === 3) {\n        return metricData.query.index;\n      } else {\n        return _.findIndex(options.targets as any[], target => {\n          if (target.filters && target.filters.length > 0) {\n            return target.metric === metricData.metric;\n          } else {\n            return (\n              target.metric === metricData.metric &&\n              _.every(target.tags, (tagV, tagK) => {\n                interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\n                arrTagV = interpolatedTagValue.split('|');\n                return _.includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\n              })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  convertToTSDBTime(date: any, roundUp: any, timezone: any) {\n    if (date === 'now') {\n      return null;\n    }\n\n    date = dateMath.parse(date, roundUp, timezone);\n    return date.valueOf();\n  }\n}\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\n\nexport class OpenTsQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n  aggregators: any;\n  fillPolicies: any;\n  filterTypes: any;\n  tsdbVersion: any;\n  aggregator: any;\n  downsampleInterval: any;\n  downsampleAggregator: any;\n  downsampleFillPolicy: any;\n  errors: any;\n  suggestMetrics: any;\n  suggestTagKeys: any;\n  suggestTagValues: any;\n  addTagMode: boolean;\n  addFilterMode: boolean;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    super($scope, $injector);\n\n    this.errors = this.validateTarget();\n    this.aggregators = ['avg', 'sum', 'min', 'max', 'dev', 'zimsum', 'mimmin', 'mimmax'];\n    this.fillPolicies = ['none', 'nan', 'null', 'zero'];\n    this.filterTypes = [\n      'wildcard',\n      'iliteral_or',\n      'not_iliteral_or',\n      'not_literal_or',\n      'iwildcard',\n      'literal_or',\n      'regexp',\n    ];\n\n    this.tsdbVersion = this.datasource.tsdbVersion;\n\n    if (!this.target.aggregator) {\n      this.target.aggregator = 'sum';\n    }\n\n    if (!this.target.downsampleAggregator) {\n      this.target.downsampleAggregator = 'avg';\n    }\n\n    if (!this.target.downsampleFillPolicy) {\n      this.target.downsampleFillPolicy = 'none';\n    }\n\n    this.datasource.getAggregators().then((aggs: { length: number }) => {\n      if (aggs.length !== 0) {\n        this.aggregators = aggs;\n      }\n    });\n\n    this.datasource.getFilterTypes().then((filterTypes: { length: number }) => {\n      if (filterTypes.length !== 0) {\n        this.filterTypes = filterTypes;\n      }\n    });\n\n    // needs to be defined here as it is called from typeahead\n    this.suggestMetrics = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('metrics(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n\n    this.suggestTagKeys = (query: any, callback: any) => {\n      this.datasource.suggestTagKeys(this.target.metric).then(callback);\n    };\n\n    this.suggestTagValues = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('suggest_tagv(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n  }\n\n  targetBlur() {\n    this.errors = this.validateTarget();\n    this.refresh();\n  }\n\n  getTextValues(metricFindResult: any) {\n    return _.map(metricFindResult, value => {\n      return value.text;\n    });\n  }\n\n  addTag() {\n    if (this.target.filters && this.target.filters.length > 0) {\n      this.errors.tags = 'Please remove filters to use tags, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addTagMode) {\n      this.addTagMode = true;\n      return;\n    }\n\n    if (!this.target.tags) {\n      this.target.tags = {};\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.tags) {\n      this.target.tags[this.target.currentTagKey] = this.target.currentTagValue;\n      this.target.currentTagKey = '';\n      this.target.currentTagValue = '';\n      this.targetBlur();\n    }\n\n    this.addTagMode = false;\n  }\n\n  removeTag(key: string | number) {\n    delete this.target.tags[key];\n    this.targetBlur();\n  }\n\n  editTag(key: string | number, value: any) {\n    this.removeTag(key);\n    this.target.currentTagKey = key;\n    this.target.currentTagValue = value;\n    this.addTag();\n  }\n\n  closeAddTagMode() {\n    this.addTagMode = false;\n    return;\n  }\n\n  addFilter() {\n    if (this.target.tags && _.size(this.target.tags) > 0) {\n      this.errors.filters = 'Please remove tags to use filters, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addFilterMode) {\n      this.addFilterMode = true;\n      return;\n    }\n\n    if (!this.target.filters) {\n      this.target.filters = [];\n    }\n\n    if (!this.target.currentFilterType) {\n      this.target.currentFilterType = 'iliteral_or';\n    }\n\n    if (!this.target.currentFilterGroupBy) {\n      this.target.currentFilterGroupBy = false;\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.filters) {\n      const currentFilter = {\n        type: this.target.currentFilterType,\n        tagk: this.target.currentFilterKey,\n        filter: this.target.currentFilterValue,\n        groupBy: this.target.currentFilterGroupBy,\n      };\n      this.target.filters.push(currentFilter);\n      this.target.currentFilterType = 'literal_or';\n      this.target.currentFilterKey = '';\n      this.target.currentFilterValue = '';\n      this.target.currentFilterGroupBy = false;\n      this.targetBlur();\n    }\n\n    this.addFilterMode = false;\n  }\n\n  removeFilter(index: number) {\n    this.target.filters.splice(index, 1);\n    this.targetBlur();\n  }\n\n  editFilter(fil: { tagk: any; filter: any; type: any; groupBy: any }, index: number) {\n    this.removeFilter(index);\n    this.target.currentFilterKey = fil.tagk;\n    this.target.currentFilterValue = fil.filter;\n    this.target.currentFilterType = fil.type;\n    this.target.currentFilterGroupBy = fil.groupBy;\n    this.addFilter();\n  }\n\n  closeAddFilterMode() {\n    this.addFilterMode = false;\n    return;\n  }\n\n  validateTarget() {\n    const errs: any = {};\n\n    if (this.target.shouldDownsample) {\n      try {\n        if (this.target.downsampleInterval) {\n          kbn.describe_interval(this.target.downsampleInterval);\n        } else {\n          errs.downsampleInterval = \"You must supply a downsample interval (e.g. '1m' or '1h').\";\n        }\n      } catch (err) {\n        errs.downsampleInterval = err.message;\n      }\n    }\n\n    if (this.target.tags && _.has(this.target.tags, this.target.currentTagKey)) {\n      errs.tags = \"Duplicate tag key '\" + this.target.currentTagKey + \"'.\";\n    }\n\n    return errs;\n  }\n}\n","import React, { SyntheticEvent } from 'react';\nimport { FormLabel, Select, Input } from '@grafana/ui';\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\nimport { OpenTsdbOptions } from '../types';\n\nconst tsdbVersions = [\n  { label: '<=2.1', value: 1 },\n  { label: '==2.2', value: 2 },\n  { label: '==2.3', value: 3 },\n];\n\nconst tsdbResolutions = [\n  { label: 'second', value: 1 },\n  { label: 'millisecond', value: 2 },\n];\n\ninterface Props {\n  value: DataSourceSettings<OpenTsdbOptions>;\n  onChange: (value: DataSourceSettings<OpenTsdbOptions>) => void;\n}\n\nexport const OpenTsdbDetails = (props: Props) => {\n  const { onChange, value } = props;\n\n  return (\n    <>\n      <h5>OpenTSDB settings</h5>\n      <div className=\"gf-form\">\n        <FormLabel width={7}>Version</FormLabel>\n        <Select\n          options={tsdbVersions}\n          value={tsdbVersions.find(version => version.value === value.jsonData.tsdbVersion) ?? tsdbVersions[0]}\n          onChange={onSelectChangeHandler('tsdbVersion', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <FormLabel width={7}>Resolution</FormLabel>\n        <Select\n          options={tsdbResolutions}\n          value={\n            tsdbResolutions.find(resolution => resolution.value === value.jsonData.tsdbResolution) ?? tsdbResolutions[0]\n          }\n          onChange={onSelectChangeHandler('tsdbResolution', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <FormLabel width={7}>Lookup Limit</FormLabel>\n        <Input\n          type=\"number\"\n          value={value.jsonData.lookupLimit ?? 1000}\n          onChange={onInputChangeHandler('lookupLimit', value, onChange)}\n        />\n      </div>\n    </>\n  );\n};\n\nconst onSelectChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  newValue: SelectableValue\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: newValue.value,\n    },\n  });\n};\n\nconst onInputChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n","import OpenTsDatasource from './datasource';\nimport { OpenTsQueryCtrl } from './query_ctrl';\nimport { DataSourcePlugin } from '@grafana/data';\nimport { ConfigEditor } from './components/ConfigEditor';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(OpenTsDatasource)\n  .setQueryCtrl(OpenTsQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setAnnotationQueryCtrl(AnnotationsQueryCtrl);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { OpenTsdbDetails } from './OpenTsdbDetails';\nimport { OpenTsdbOptions } from '../types';\n\nexport const ConfigEditor = (props: DataSourcePluginOptionsEditorProps<OpenTsdbOptions>) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:4242\"\n        dataSourceConfig={options}\n        onChange={onOptionsChange}\n      />\n      <OpenTsdbDetails value={options} onChange={onOptionsChange} />\n    </>\n  );\n};\n"],"sourceRoot":""}