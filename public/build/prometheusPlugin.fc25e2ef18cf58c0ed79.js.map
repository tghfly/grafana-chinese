{"version":3,"sources":["webpack:///./public/app/plugins/datasource/prometheus/metric_find_query.ts","webpack:///./public/app/plugins/datasource/prometheus/result_transformer.ts","webpack:///./public/app/plugins/datasource/prometheus/language_provider.ts","webpack:///./public/app/plugins/datasource/prometheus/query_hints.ts","webpack:///./public/app/plugins/datasource/prometheus/datasource.ts","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromLink.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx","webpack:///./public/app/plugins/datasource/prometheus/module.ts","webpack:///./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx","webpack:///./public/app/core/utils/CancelablePromise.ts"],"names":["PrometheusMetricFindQuery","datasource","query","this","range","getTimeSrv","timeRange","match","labelNamesQuery","labelValuesQuery","metricNamesQuery","metricNameQuery","queryResultQuery","metricNameAndLabelsQuery","metadataRequest","then","result","_","map","data","value","text","label","metric","url","start","getPrometheusTime","from","end","to","encodeURIComponent","_labels","filter","uniq","expandable","metricFilterPattern","chain","metricName","RegExp","test","matchedMetricName","instantQuery","expr","performInstantQuery","metricData","__name__","v","k","join","self","getOriginalMetricName","ResultTransformer","templateSrv","response","options","prometheusResult","format","transformMetricDataToTable","responseListLength","refId","valueWithRefId","seriesList","push","transformMetricData","sort","sortSeriesByLabel","transformToHistogramOverTime","resultType","transformInstantMetricData","metricLabel","dps","createMetricLabel","stepMs","parseFloat","step","baseTimestamp","undefined","values","Error","dpValue","isNaN","timestamp","t","endTimestamp","datapoints","target","tags","md","resultCount","i","j","table","TableModel","metricLabels","length","each","series","hasOwnProperty","sortedLabels","keys","columns","type","FieldType","time","labelIndex","filterable","valueText","reordered","rows","labelData","isUndefined","isEmpty","legendFormat","renderTemplate","replace","aliasPattern","aliasData","g1","toPairs","topSeries","bottomSeries","bottomPoint","s1","s2","le1","le2","parseHistogramLabel","err","console","log","le","Infinity","Number","DEFAULT_KEYS","wrapLabel","setFunctionKind","suggestion","kind","PREFIX_DELIMITER_REGEX","PromQlLanguageProvider","initialValues","labelsCache","LRU","request","defaultValue","res","json","body","error","metrics","lookupsDisabled","lookupMetricsThreshold","metricsMetadata","processHistogramMetrics","processHistogramLabels","histogramMetrics","slice","provideCompletionItems","prefix","labelKey","wrapperClasses","context","history","empty","document","selectedLines","getTextsAtRange","selection","currentLine","size","first","getText","nextCharacter","anchor","offset","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","operatorsPattern","isNextOperand","includes","getRangeCompletionItems","getLabelCompletionItems","getAggregationCompletionItems","getEmptyCompletionItems","getBeginningCompletionItems","getTermCompletionItems","suggestions","historyItems","h","take","item","cutoffTs","Date","now","historyForItem","ts","count","recent","hint","lastQueried","dateTime","fromNow","documentation","addHistoryMetadata","prefixMatch","skipSort","items","FUNCTIONS","m","metadata","help","toUpperCase","addMetricsMetadata","queryText","getBlocks","reduce","block","blockText","anchorBlock","key","queryOffset","openParensAggregationIndex","lastIndexOf","openParensSelectorIndex","closeParensSelectorIndex","indexOf","closeParensAggregationIndex","selectorString","selector","parseSelector","getLabelValues","labelValues","Object","line","cursorOffset","suffix","substr","isValueStart","isValueEnd","isPreValue","hasValuePrefix","parsedSelector","containsMetric","existingKeys","labelKeys","warn","possibleKeys","difference","newItems","newSuggestion","fetchLabelValues","fetchSeriesLabels","name","withName","tRange","getTimeRange","cacheKey","roundToMinutes","get","processLabels","set","fetchDefaultLabels","once","Promise","all","acc","assign","s","split","pop","trimLeft","RATE_RANGES","seconds","Math","floor","PromqlSyntax","LanguageProvider","getQueryHints","hints","trim","fix","action","nameMatch","counterNameMetric","languageProvider","certain","find","toLowerCase","metricRegex","simpleMetric","verb","ruleMappings","mapping","mappingForQuery","ruleName","search","preventSubmit","PrometheusDatasource","instanceSettings","init","loadRules","processResult","transformerOptions","resultTransformer","transform","prepareTargets","queries","activeTargets","targets","hide","requestId","panelId","app","CoreApp","Explore","showingTable","instantTarget","cloneDeep","instant","maxDataPoints","createQuery","showingGraph","handleErrors","message","statusText","safeStringifyValue","status","createAnnotationQueryOptions","annotation","interval","editorSrc","basicAuth","withCredentials","jsonData","timeInterval","queryTimeout","httpMethod","directUrl","PrometheusLanguageProvider","customQueryParameters","URLSearchParams","httpOptions","headers","dashboardId","defaults","method","entries","transformRequest","$","param","Authorization","getBackendSrv","datasourceRequest","_request","silent","variable","multi","includeAll","prometheusRegularEscape","prometheusSpecialRegexEscape","escapedValues","val","variableExists","exploreQuery","panelsQuery","of","state","LoadingState","Done","runningQueriesCount","subQueries","index","performTimeSeriesQuery","pipe","tap","cancelled","Loading","merge","observables","forkJoin","results","current","hinting","ceil","kbn","interval_to_seconds","minInterval","scopedVars","intervalFactor","adjustedInterval","adjustInterval","getRangeScopedVars","__interval","__interval_ms","getAdhocFilters","operator","addLabelToQuery","interpolateQueryExpr","adjusted","utcOffsetSec","alignedEnd","alignedStart","alignRange","utcOffset","_addTracingHeaders","safeInterval","max","catch","metricsNameCache","expire","resolve","interval_to_ms","interpolated","metricFindQuery","process","msRange","diff","sRange","round","__range_ms","__range_s","__range","tagKeys","titleFormat","textFormat","queryOptions","queryModel","eventList","splitKeys","forEach","timestampValue","useValueForTime","activeValuesTimestamps","latestEvent","timeEnd","title","getTime","expandedQueries","groups","extractRuleMappingFromGroups","expression","expandRecordingRules","date","roundUp","dateMath","parse","valueOf","DataSourceApi","group","rules","rule","HISTOGRAM_GROUP","willApplySuggestion","typeaheadContext","typeaheadText","nextChar","DOMUtil","getNextCharacter","PromQueryField","props","refreshHint","isDataFrame","toLegacyResponseData","setState","refreshMetrics","cancelablePromise","languageProviderInitializationPromise","promise","remaining","task","onUpdateLanguage","isCanceled","onChangeMetrics","selectedOptions","children","onChangeQuery","override","onChange","onRunQuery","onClickHintFix","modifyQuery","metricsByPrefix","ruleRegex","ruleNames","rulesOption","metricsOptions","groupBy","metricsForPrefix","option","sortBy","groupMetricsByPrefix","histogramOptions","hm","isLeaf","syntaxLoaded","onTypeahead","typeahead","plugins","BracesPlugin","SlatePrism","onlyIn","node","getSyntax","Prism","languages","syntax","makePromiseCancelable","cancel","prevProps","ExtraFieldElement","cleanText","chooserText","buttonDisabled","className","disabled","additionalPlugins","onWillApplySuggestion","onBlur","placeholder","portalOrigin","onClick","React","PureComponent","PromLink","href","panelData","getExternalLink","datasourceName","getDatasourceSrv","rangeDiff","endTime","utc","args","rel","Component","FORMAT_OPTIONS","INTERVAL_FACTOR_OPTIONS","PromQueryEditor","onFieldChange","onFormatChange","formatOption","onInstantChange","e","checked","onIntervalChange","currentTarget","onIntervalFactorChange","intervalFactorOption","onLegendChange","Boolean","width","tooltip","isSearchable","CHEAT_SHEET_ITEMS","PromExploreExtraField","onChangeFunc","onKeyDownFunc","hasTooltip","tooltipContent","onKeyDown","memo","onChangeQueryStep","PromSettings","labelWidth","inputEl","spellCheck","onChangeHandler","validationEvents","promSettingsValidationEvents","o","EventsWithValidation","regexValidation","getValueFromEventItem","eventItem","PrometheusAnnotationsQueryCtrl","stepDefaultValuePlaceholder","templateUrl","plugin","DataSourcePlugin","setQueryEditor","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","setExploreMetricsQueryField","PromExploreQueryEditor","setAnnotationQueryCtrl","setExploreStartPage","onClickExample","hasCanceled_","reject"],"mappings":"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","file":"prometheusPlugin.fc25e2ef18cf58c0ed79.js","sourcesContent":["import _ from 'lodash';\nimport { TimeRange } from '@grafana/data';\nimport { PrometheusDatasource, PromDataQueryResponse } from './datasource';\nimport { PromQueryRequest } from './types';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\n\nexport default class PrometheusMetricFindQuery {\n  range: TimeRange;\n\n  constructor(private datasource: PrometheusDatasource, private query: string) {\n    this.datasource = datasource;\n    this.query = query;\n    this.range = getTimeSrv().timeRange();\n  }\n\n  process() {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n    const metricNamesRegex = /^metrics\\((.+)\\)\\s*$/;\n    const queryResultRegex = /^query_result\\((.+)\\)\\s*$/;\n    const labelNamesQuery = this.query.match(labelNamesRegex);\n    if (labelNamesQuery) {\n      return this.labelNamesQuery();\n    }\n\n    const labelValuesQuery = this.query.match(labelValuesRegex);\n    if (labelValuesQuery) {\n      if (labelValuesQuery[1]) {\n        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);\n      } else {\n        return this.labelValuesQuery(labelValuesQuery[2], null);\n      }\n    }\n\n    const metricNamesQuery = this.query.match(metricNamesRegex);\n    if (metricNamesQuery) {\n      return this.metricNameQuery(metricNamesQuery[1]);\n    }\n\n    const queryResultQuery = this.query.match(queryResultRegex);\n    if (queryResultQuery) {\n      return this.queryResultQuery(queryResultQuery[1]);\n    }\n\n    // if query contains full metric name, return metric name and label list\n    return this.metricNameAndLabelsQuery(this.query);\n  }\n\n  labelNamesQuery() {\n    const url = '/api/v1/labels';\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, value => {\n        return { text: value };\n      });\n    });\n  }\n\n  labelValuesQuery(label: string, metric?: string) {\n    let url: string;\n\n    if (!metric) {\n      // return label values globally\n      url = '/api/v1/label/' + label + '/values';\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        return _.map(result.data.data, value => {\n          return { text: value };\n        });\n      });\n    } else {\n      const start = this.datasource.getPrometheusTime(this.range.from, false);\n      const end = this.datasource.getPrometheusTime(this.range.to, true);\n      url = '/api/v1/series?match[]=' + encodeURIComponent(metric) + '&start=' + start + '&end=' + end;\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        const _labels = _.map(result.data.data, metric => {\n          return metric[label] || '';\n        }).filter(label => {\n          return label !== '';\n        });\n\n        return _.uniq(_labels).map(metric => {\n          return {\n            text: metric,\n            expandable: true,\n          };\n        });\n      });\n    }\n  }\n\n  metricNameQuery(metricFilterPattern: string) {\n    const url = '/api/v1/label/__name__/values';\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.chain(result.data.data)\n        .filter(metricName => {\n          const r = new RegExp(metricFilterPattern);\n          return r.test(metricName);\n        })\n        .map(matchedMetricName => {\n          return {\n            text: matchedMetricName,\n            expandable: true,\n          };\n        })\n        .value();\n    });\n  }\n\n  queryResultQuery(query: string) {\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const instantQuery: PromQueryRequest = { expr: query } as PromQueryRequest;\n    return this.datasource.performInstantQuery(instantQuery, end).then((result: PromDataQueryResponse) => {\n      return _.map(result.data.data.result, metricData => {\n        let text = metricData.metric.__name__ || '';\n        delete metricData.metric.__name__;\n        text +=\n          '{' +\n          _.map(metricData.metric, (v, k) => {\n            return k + '=\"' + v + '\"';\n          }).join(',') +\n          '}';\n        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;\n\n        return {\n          text: text,\n          expandable: true,\n        };\n      });\n    });\n  }\n\n  metricNameAndLabelsQuery(query: string) {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const url = '/api/v1/series?match[]=' + encodeURIComponent(query) + '&start=' + start + '&end=' + end;\n\n    const self = this;\n    return this.datasource.metadataRequest(url).then((result: PromDataQueryResponse) => {\n      return _.map(result.data.data, (metric: { [key: string]: string }) => {\n        return {\n          text: self.datasource.getOriginalMetricName(metric),\n          expandable: true,\n        };\n      });\n    });\n  }\n}\n","import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { TimeSeries, FieldType } from '@grafana/data';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport class ResultTransformer {\n  constructor(private templateSrv: TemplateSrv) {}\n\n  transform(response: any, options: any): Array<TableModel | TimeSeries> {\n    const prometheusResult = response.data.data.result;\n\n    if (options.format === 'table') {\n      return [\n        this.transformMetricDataToTable(\n          prometheusResult,\n          options.responseListLength,\n          options.refId,\n          options.valueWithRefId\n        ),\n      ];\n    } else if (prometheusResult && options.format === 'heatmap') {\n      let seriesList = [];\n      for (const metricData of prometheusResult) {\n        seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\n      }\n      seriesList.sort(sortSeriesByLabel);\n      seriesList = this.transformToHistogramOverTime(seriesList);\n      return seriesList;\n    } else if (prometheusResult) {\n      const seriesList = [];\n      for (const metricData of prometheusResult) {\n        if (response.data.data.resultType === 'matrix') {\n          seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\n        } else if (response.data.data.resultType === 'vector') {\n          seriesList.push(this.transformInstantMetricData(metricData, options));\n        }\n      }\n      return seriesList;\n    }\n    return [];\n  }\n\n  transformMetricData(metricData: any, options: any, start: number, end: number) {\n    const dps = [];\n    let metricLabel = null;\n\n    metricLabel = this.createMetricLabel(metricData.metric, options);\n\n    const stepMs = parseFloat(options.step) * 1000;\n    let baseTimestamp = start * 1000;\n\n    if (metricData.values === undefined) {\n      throw new Error('Prometheus heatmap error: data should be a time series');\n    }\n\n    for (const value of metricData.values) {\n      let dpValue = parseFloat(value[1]);\n      if (_.isNaN(dpValue)) {\n        dpValue = null;\n      }\n\n      const timestamp = parseFloat(value[0]) * 1000;\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\n        dps.push([null, t]);\n      }\n      baseTimestamp = timestamp + stepMs;\n      dps.push([dpValue, timestamp]);\n    }\n\n    const endTimestamp = end * 1000;\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\n      dps.push([null, t]);\n    }\n\n    return {\n      datapoints: dps,\n      query: options.query,\n      refId: options.refId,\n      target: metricLabel,\n      tags: metricData.metric,\n    };\n  }\n\n  transformMetricDataToTable(md: any, resultCount: number, refId: string, valueWithRefId?: boolean): TableModel {\n    const table = new TableModel();\n    table.refId = refId;\n\n    let i: number, j: number;\n    const metricLabels: { [key: string]: number } = {};\n\n    if (!md || md.length === 0) {\n      return table;\n    }\n\n    // Collect all labels across all metrics\n    _.each(md, series => {\n      for (const label in series.metric) {\n        if (!metricLabels.hasOwnProperty(label)) {\n          metricLabels[label] = 1;\n        }\n      }\n    });\n\n    // Sort metric labels, create columns for them and record their index\n    const sortedLabels = _.keys(metricLabels).sort();\n    table.columns.push({ text: 'Time', type: FieldType.time });\n    _.each(sortedLabels, (label, labelIndex) => {\n      metricLabels[label] = labelIndex + 1;\n      table.columns.push({ text: label, filterable: true });\n    });\n    const valueText = resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value';\n    table.columns.push({ text: valueText });\n\n    // Populate rows, set value to empty string when label not present.\n    _.each(md, series => {\n      if (series.value) {\n        series.values = [series.value];\n      }\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered: any = [values[0] * 1000];\n          if (series.metric) {\n            for (j = 0; j < sortedLabels.length; j++) {\n              const label = sortedLabels[j];\n              if (series.metric.hasOwnProperty(label)) {\n                reordered.push(series.metric[label]);\n              } else {\n                reordered.push('');\n              }\n            }\n          }\n          reordered.push(parseFloat(values[1]));\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n\n  transformInstantMetricData(md: any, options: any) {\n    const dps = [];\n    let metricLabel = null;\n    metricLabel = this.createMetricLabel(md.metric, options);\n    dps.push([parseFloat(md.value[1]), md.value[0] * 1000]);\n    return { target: metricLabel, datapoints: dps, tags: md.metric, refId: options.refId };\n  }\n\n  createMetricLabel(labelData: { [key: string]: string }, options: any) {\n    let label = '';\n    if (_.isUndefined(options) || _.isEmpty(options.legendFormat)) {\n      label = this.getOriginalMetricName(labelData);\n    } else {\n      label = this.renderTemplate(this.templateSrv.replace(options.legendFormat), labelData);\n    }\n    if (!label || label === '{}') {\n      label = options.query;\n    }\n    return label;\n  }\n\n  renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n    const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n    return aliasPattern.replace(aliasRegex, (match, g1) => {\n      if (aliasData[g1]) {\n        return aliasData[g1];\n      }\n      return g1;\n    });\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    const metricName = labelData.__name__ || '';\n    delete labelData.__name__;\n    const labelPart = _.map(_.toPairs(labelData), label => {\n      return label[0] + '=\"' + label[1] + '\"';\n    }).join(',');\n    return metricName + '{' + labelPart + '}';\n  }\n\n  transformToHistogramOverTime(seriesList: TimeSeries[]) {\n    /*      t1 = timestamp1, t2 = timestamp2 etc.\n            t1  t2  t3          t1  t2  t3\n    le10    10  10  0     =>    10  10  0\n    le20    20  10  30    =>    10  0   30\n    le30    30  10  35    =>    10  0   5\n    */\n    for (let i = seriesList.length - 1; i > 0; i--) {\n      const topSeries = seriesList[i].datapoints;\n      const bottomSeries = seriesList[i - 1].datapoints;\n      if (!topSeries || !bottomSeries) {\n        throw new Error('Prometheus heatmap transform error: data should be a time series');\n      }\n\n      for (let j = 0; j < topSeries.length; j++) {\n        const bottomPoint = bottomSeries[j] || [0];\n        topSeries[j][0] -= bottomPoint[0];\n      }\n    }\n\n    return seriesList;\n  }\n}\n\nfunction sortSeriesByLabel(s1: TimeSeries, s2: TimeSeries): number {\n  let le1, le2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    le1 = parseHistogramLabel(s1.target);\n    le2 = parseHistogramLabel(s2.target);\n  } catch (err) {\n    console.log(err);\n    return 0;\n  }\n\n  if (le1 > le2) {\n    return 1;\n  }\n\n  if (le1 < le2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseHistogramLabel(le: string): number {\n  if (le === '+Inf') {\n    return +Infinity;\n  }\n  return Number(le);\n}\n","import _ from 'lodash';\nimport LRU from 'lru-cache';\nimport { Value } from 'slate';\n\nimport { dateTime, LanguageProvider, HistoryItem } from '@grafana/data';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\n\nimport { parseSelector, processLabels, processHistogramLabels } from './language_utils';\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\n\nimport { PrometheusDatasource } from './datasource';\nimport { PromQuery, PromMetricsMetadata } from './types';\n\nconst DEFAULT_KEYS = ['job', 'instance'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 5;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nexport const DEFAULT_LOOKUP_METRICS_THRESHOLD = 10000; // number of metrics defining an installation that's too big\n\nconst wrapLabel = (label: string): CompletionItem => ({ label });\n\nconst setFunctionKind = (suggestion: CompletionItem): CompletionItem => {\n  suggestion.kind = 'function';\n  return suggestion;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: any[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CompletionItem {\n  const item: CompletionItem = { label: metric };\n  if (metadata && metadata[metric]) {\n    const { type, help } = metadata[metric][0];\n    item.documentation = `${type.toUpperCase()}: ${help}`;\n  }\n  return item;\n}\n\nconst PREFIX_DELIMITER_REGEX = /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\n\nexport default class PromQlLanguageProvider extends LanguageProvider {\n  histogramMetrics?: string[];\n  timeRange?: { start: number; end: number };\n  metrics?: string[];\n  metricsMetadata?: PromMetricsMetadata;\n  startTask: Promise<any>;\n  datasource: PrometheusDatasource;\n  lookupMetricsThreshold: number;\n  lookupsDisabled: boolean; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private labelsCache = new LRU<string, Record<string, string[]>>(10);\n\n  constructor(datasource: PrometheusDatasource, initialValues?: Partial<PromQlLanguageProvider>) {\n    super();\n\n    this.datasource = datasource;\n    this.histogramMetrics = [];\n    this.timeRange = { start: 0, end: 0 };\n    this.metrics = [];\n    // Disable lookups until we know the instance is small enough\n    this.lookupMetricsThreshold = DEFAULT_LOOKUP_METRICS_THRESHOLD;\n    this.lookupsDisabled = true;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars so that typeahead suggestions can work on clean inputs\n  cleanText(s: string) {\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\n    const last = parts.pop();\n    return last\n      .trimLeft()\n      .replace(/\"$/, '')\n      .replace(/^\"/, '');\n  }\n\n  get syntax() {\n    return PromqlSyntax;\n  }\n\n  request = async (url: string, defaultValue: any): Promise<any> => {\n    try {\n      const res = await this.datasource.metadataRequest(url);\n      const body = await (res.data || res.json());\n\n      return body.data;\n    } catch (error) {\n      console.error(error);\n    }\n\n    return defaultValue;\n  };\n\n  start = async (): Promise<any[]> => {\n    this.metrics = await this.request('/api/v1/label/__name__/values', []);\n    this.lookupsDisabled = this.metrics.length > this.lookupMetricsThreshold;\n    this.metricsMetadata = await this.request('/api/v1/metadata', {});\n    this.processHistogramMetrics(this.metrics);\n    return [];\n  };\n\n  processHistogramMetrics = (data: string[]) => {\n    const { values } = processHistogramLabels(data);\n\n    if (values && values['__name__']) {\n      this.histogramMetrics = values['__name__'].slice().sort();\n    }\n  };\n\n  provideCompletionItems = async (\n    { prefix, text, value, labelKey, wrapperClasses }: TypeaheadInput,\n    context: { history: Array<HistoryItem<PromQuery>> } = { history: [] }\n  ): Promise<TypeaheadOutput> => {\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n      return this.getLabelCompletionItems({ prefix, text, value, labelKey, wrapperClasses });\n    } else if (wrapperClasses.includes('context-aggregation')) {\n      // Suggestions for sum(metric) by (|)\n      return this.getAggregationCompletionItems(value);\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return {\n      suggestions: [],\n    };\n  };\n\n  getBeginningCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length) {\n      const historyItems = _.chain(history)\n        .map(h => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map(item => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const { metrics, metricsMetadata } = this;\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map(setFunctionKind),\n    });\n\n    if (metrics && metrics.length) {\n      suggestions.push({\n        label: 'Metrics',\n        items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  getAggregationCompletionItems = async (value: Value): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n\n    // Stitch all query lines together to support multi-line queries\n    let queryOffset;\n    const queryText = value.document.getBlocks().reduce((text: string, block) => {\n      const blockText = block.getText();\n      if (value.anchorBlock.key === block.key) {\n        // Newline characters are not accounted for but this is irrelevant\n        // for the purpose of extracting the selector string\n        queryOffset = value.selection.anchor.offset + text.length;\n      }\n\n      return text + blockText;\n    }, '');\n\n    // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\n    const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\n    let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\n    let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex);\n\n    // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\n    if (openParensSelectorIndex === -1) {\n      const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\n      closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\n      openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\n    }\n\n    const result = {\n      suggestions,\n      context: 'context-aggregation',\n    };\n\n    // Suggestions are useless for alternative aggregation clauses without a selector in context\n    if (openParensSelectorIndex === -1) {\n      return result;\n    }\n\n    // Range vector syntax not accounted for by subsequent parse so discard it if present\n    const selectorString = queryText\n      .slice(openParensSelectorIndex + 1, closeParensSelectorIndex)\n      .replace(/\\[[^\\]]+\\]$/, '');\n\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\n\n    const labelValues = await this.getLabelValues(selector);\n    if (labelValues) {\n      suggestions.push({ label: 'Labels', items: Object.keys(labelValues).map(wrapLabel) });\n    }\n    return result;\n  };\n\n  getLabelCompletionItems = async ({\n    text,\n    wrapperClasses,\n    labelKey,\n    value,\n  }: TypeaheadInput): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const suffix = line.substr(cursorOffset);\n    const prefix = line.substr(0, cursorOffset);\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n    const isValueEnd = suffix.match(/^\"?[,}]/);\n    // detect cursor in front of value, e.g., {key=|\"}\n    const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/);\n\n    // Don't suggestq anything at the beginning or inside a value\n    const isValueEmpty = isValueStart && isValueEnd;\n    const hasValuePrefix = isValueEnd && !isValueStart;\n    if ((!isValueEmpty && !hasValuePrefix) || isPreValue) {\n      return { suggestions };\n    }\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    const containsMetric = selector.includes('__name__=');\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      labelValues = await this.getLabelValues(selector, !containsMetric);\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { suggestions };\n    }\n\n    let context: string;\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          items: labelValues[labelKey].map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : containsMetric ? null : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          context = 'context-labels';\n          const newItems = possibleKeys.map(key => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  };\n\n  async getLabelValues(selector: string, withName?: boolean) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      if (selector === EMPTY_SELECTOR) {\n        return await this.fetchDefaultLabels();\n      } else {\n        return await this.fetchSeriesLabels(selector, withName);\n      }\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  fetchLabelValues = async (key: string): Promise<Record<string, string[]>> => {\n    const data = await this.request(`/api/v1/label/${key}/values`, []);\n    return { [key]: data };\n  };\n\n  roundToMinutes(seconds: number): number {\n    return Math.floor(seconds / 60);\n  }\n\n  /**\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   * @param withName\n   */\n  fetchSeriesLabels = async (name: string, withName?: boolean): Promise<Record<string, string[]>> => {\n    const tRange = this.datasource.getTimeRange();\n    const url = `/api/v1/series?match[]=${name}&start=${tRange['start']}&end=${tRange['end']}`;\n    // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\n    // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n    // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n    // when user does not the newest values for a minute if already cached.\n    const cacheKey = `/api/v1/series?match[]=${name}&start=${this.roundToMinutes(\n      tRange['start']\n    )}&end=${this.roundToMinutes(tRange['end'])}&withName=${!!withName}`;\n    let value = this.labelsCache.get(cacheKey);\n    if (!value) {\n      const data = await this.request(url, []);\n      const { values } = processLabels(data, withName);\n      value = values;\n      this.labelsCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch this only one as we assume this won't change over time. This is cached differently from fetchSeriesLabels\n   * because we can cache more aggressively here and also we do not want to invalidate this cache the same way as in\n   * fetchSeriesLabels.\n   */\n  fetchDefaultLabels = _.once(async () => {\n    const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));\n    return values.reduce((acc, value) => ({ ...acc, ...value }), {});\n  });\n}\n","import _ from 'lodash';\nimport { QueryHint, QueryFix } from '@grafana/data';\nimport { PrometheusDatasource } from './datasource';\n\n/**\n * Number of time series results needed before starting to suggest sum aggregation hints\n */\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\n\nexport function getQueryHints(query: string, series?: any[], datasource?: PrometheusDatasource): QueryHint[] | null {\n  const hints = [];\n\n  // ..._bucket metric needs a histogram_quantile()\n  const histogramMetric = query.trim().match(/^\\w+_bucket$/);\n  if (histogramMetric) {\n    const label = 'Time series has buckets, you probably wanted a histogram.';\n    hints.push({\n      type: 'HISTOGRAM_QUANTILE',\n      label,\n      fix: {\n        label: 'Fix by adding histogram_quantile().',\n        action: {\n          type: 'ADD_HISTOGRAM_QUANTILE',\n          query,\n        },\n      } as QueryFix,\n    });\n  }\n\n  // Check for need of rate()\n  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {\n    // Use metric metadata for exact types\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\n    const metricsMetadata = datasource?.languageProvider?.metricsMetadata;\n    let certain = false;\n    if (_.size(metricsMetadata) > 0) {\n      counterNameMetric = Object.keys(metricsMetadata).find(metricName => {\n        // Only considering first type information, could be non-deterministic\n        const metadata = metricsMetadata[metricName][0];\n        if (metadata.type.toLowerCase() === 'counter') {\n          const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\n          if (query.match(metricRegex)) {\n            certain = true;\n            return true;\n          }\n        }\n        return false;\n      });\n    }\n    if (counterNameMetric) {\n      const simpleMetric = query.trim().match(/^\\w+$/);\n      const verb = certain ? 'is' : 'looks like';\n      let label = `Metric ${counterNameMetric} ${verb} a counter.`;\n      let fix: QueryFix;\n      if (simpleMetric) {\n        fix = {\n          label: 'Fix by adding rate().',\n          action: {\n            type: 'ADD_RATE',\n            query,\n          },\n        } as QueryFix;\n      } else {\n        label = `${label} Try applying a rate() function.`;\n      }\n      hints.push({\n        type: 'APPLY_RATE',\n        label,\n        fix,\n      });\n    }\n  }\n\n  // Check for recording rules expansion\n  if (datasource && datasource.ruleMappings) {\n    const mapping = datasource.ruleMappings;\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\n      if (query.search(ruleName) > -1) {\n        return {\n          ...acc,\n          [ruleName]: mapping[ruleName],\n        };\n      }\n      return acc;\n    }, {});\n    if (_.size(mappingForQuery) > 0) {\n      const label = 'Query contains recording rules.';\n      hints.push({\n        type: 'EXPAND_RULES',\n        label,\n        fix: ({\n          label: 'Expand rules',\n          action: {\n            type: 'EXPAND_RULES',\n            query,\n            mapping: mappingForQuery,\n          },\n        } as any) as QueryFix,\n      });\n    }\n  }\n\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\n    const simpleMetric = query.trim().match(/^\\w+$/);\n    if (simpleMetric) {\n      hints.push({\n        type: 'ADD_SUM',\n        label: 'Many time series results returned.',\n        fix: {\n          label: 'Consider aggregating with sum().',\n          action: {\n            type: 'ADD_SUM',\n            query: query,\n            preventSubmit: true,\n          },\n        } as QueryFix,\n      });\n    }\n  }\n\n  return hints.length > 0 ? hints : null;\n}\n","// Libraries\nimport cloneDeep from 'lodash/cloneDeep';\nimport defaults from 'lodash/defaults';\nimport $ from 'jquery';\n// Services & Utils\nimport kbn from 'app/core/utils/kbn';\nimport {\n  AnnotationEvent,\n  CoreApp,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQueryResponseData,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  LoadingState,\n  ScopedVars,\n  TimeRange,\n  TimeSeries,\n} from '@grafana/data';\nimport { forkJoin, from, merge, Observable, of } from 'rxjs';\nimport { filter, map, tap } from 'rxjs/operators';\n\nimport PrometheusMetricFindQuery from './metric_find_query';\nimport { ResultTransformer } from './result_transformer';\nimport PrometheusLanguageProvider from './language_provider';\nimport { getBackendSrv } from '@grafana/runtime';\nimport addLabelToQuery from './add_label_to_query';\nimport { getQueryHints } from './query_hints';\nimport { expandRecordingRules } from './language_utils';\n// Types\nimport { PromOptions, PromQuery, PromQueryRequest } from './types';\nimport { safeStringifyValue } from 'app/core/utils/explore';\nimport templateSrv from 'app/features/templating/template_srv';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport TableModel from 'app/core/table_model';\n\nexport const ANNOTATION_QUERY_STEP_DEFAULT = '60s';\n\ninterface RequestOptions {\n  method?: string;\n  url?: string;\n  headers?: Record<string, string>;\n  transformRequest?: (data: any) => string;\n  data?: any;\n  withCredentials?: boolean;\n  silent?: boolean;\n  requestId?: string;\n}\n\nexport interface PromDataQueryResponse {\n  data: {\n    status: string;\n    data: {\n      resultType: string;\n      results?: DataQueryResponseData[];\n      result?: DataQueryResponseData[];\n    };\n  };\n  cancelled?: boolean;\n}\n\nexport interface PromLabelQueryResponse {\n  data: {\n    status: string;\n    data: string[];\n  };\n  cancelled?: boolean;\n}\n\nexport class PrometheusDatasource extends DataSourceApi<PromQuery, PromOptions> {\n  type: string;\n  editorSrc: string;\n  ruleMappings: { [index: string]: string };\n  url: string;\n  directUrl: string;\n  basicAuth: any;\n  withCredentials: any;\n  metricsNameCache: any;\n  interval: string;\n  queryTimeout: string;\n  httpMethod: string;\n  languageProvider: PrometheusLanguageProvider;\n  resultTransformer: ResultTransformer;\n  customQueryParameters: any;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<PromOptions>) {\n    super(instanceSettings);\n\n    this.type = 'prometheus';\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\n    this.url = instanceSettings.url;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n    this.directUrl = instanceSettings.jsonData.directUrl;\n    this.resultTransformer = new ResultTransformer(templateSrv);\n    this.ruleMappings = {};\n    this.languageProvider = new PrometheusLanguageProvider(this);\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n  }\n\n  init = () => {\n    this.loadRules();\n  };\n\n  getQueryDisplayText(query: PromQuery) {\n    return query.expr;\n  }\n\n  _addTracingHeaders(httpOptions: PromQueryRequest, options: DataQueryRequest<PromQuery>) {\n    httpOptions.headers = {};\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n\n  _request(url: string, data: Record<string, string> = {}, options?: RequestOptions) {\n    options = defaults(options || {}, {\n      url: this.url + url,\n      method: this.httpMethod,\n      headers: {},\n    });\n\n    if (options.method === 'GET') {\n      if (data && Object.keys(data).length) {\n        options.url =\n          options.url +\n          '?' +\n          Object.entries(data)\n            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n            .join('&');\n      }\n    } else {\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.transformRequest = (data: any) => $.param(data);\n      options.data = data;\n    }\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers.Authorization = this.basicAuth;\n    }\n\n    return getBackendSrv().datasourceRequest(options as Required<RequestOptions>);\n  }\n\n  // Use this for tab completion features, wont publish response to other components\n  metadataRequest(url: string) {\n    return this._request(url, null, { method: 'GET', silent: true });\n  }\n\n  interpolateQueryExpr(value: string | string[] = [], variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return prometheusRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return prometheusSpecialRegexEscape(value);\n    }\n\n    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));\n    return escapedValues.join('|');\n  }\n\n  targetContainsTemplate(target: PromQuery) {\n    return templateSrv.variableExists(target.expr);\n  }\n\n  processResult = (response: any, query: PromQueryRequest, target: PromQuery, responseListLength: number) => {\n    // Keeping original start/end for transformers\n    const transformerOptions = {\n      format: target.format,\n      step: query.step,\n      legendFormat: target.legendFormat,\n      start: query.start,\n      end: query.end,\n      query: query.expr,\n      responseListLength,\n      refId: target.refId,\n      valueWithRefId: target.valueWithRefId,\n    };\n    const series = this.resultTransformer.transform(response, transformerOptions);\n\n    return series;\n  };\n\n  prepareTargets = (options: DataQueryRequest<PromQuery>, start: number, end: number) => {\n    const queries: PromQueryRequest[] = [];\n    const activeTargets: PromQuery[] = [];\n\n    for (const target of options.targets) {\n      if (!target.expr || target.hide) {\n        continue;\n      }\n\n      target.requestId = options.panelId + target.refId;\n\n      if (options.app !== CoreApp.Explore) {\n        activeTargets.push(target);\n        queries.push(this.createQuery(target, options, start, end));\n        continue;\n      }\n\n      if (target.showingTable) {\n        // create instant target only if Table is showed in Explore\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        instantTarget.instant = true;\n        instantTarget.valueWithRefId = true;\n        delete instantTarget.maxDataPoints;\n        instantTarget.requestId += '_instant';\n\n        activeTargets.push(instantTarget);\n        queries.push(this.createQuery(instantTarget, options, start, end));\n      }\n\n      if (target.showingGraph) {\n        // create time series target only if Graph is showed in Explore\n        target.format = 'time_series';\n        target.instant = false;\n\n        activeTargets.push(target);\n        queries.push(this.createQuery(target, options, start, end));\n      }\n    }\n\n    return {\n      queries,\n      activeTargets,\n    };\n  };\n\n  query(options: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const { queries, activeTargets } = this.prepareTargets(options, start, end);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (!queries || !queries.length) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    if (options.app === CoreApp.Explore) {\n      return this.exploreQuery(queries, activeTargets, end);\n    }\n\n    return this.panelsQuery(queries, activeTargets, end, options.requestId);\n  }\n\n  private exploreQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number) {\n    let runningQueriesCount = queries.length;\n    const subQueries = queries.map((query, index) => {\n      const target = activeTargets[index];\n      let observable: Observable<any> = null;\n\n      if (query.instant) {\n        observable = from(this.performInstantQuery(query, end));\n      } else {\n        observable = from(this.performTimeSeriesQuery(query, query.start, query.end));\n      }\n\n      return observable.pipe(\n        // Decrease the counter here. We assume that each request returns only single value and then completes\n        // (should hold until there is some streaming requests involved).\n        tap(() => runningQueriesCount--),\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = this.processResult(response, query, target, queries.length);\n          return {\n            data,\n            key: query.requestId,\n            state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading,\n          } as DataQueryResponse;\n        })\n      );\n    });\n\n    return merge(...subQueries);\n  }\n\n  private panelsQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number, requestId: string) {\n    const observables: Array<Observable<Array<TableModel | TimeSeries>>> = queries.map((query, index) => {\n      const target = activeTargets[index];\n      let observable: Observable<any> = null;\n\n      if (query.instant) {\n        observable = from(this.performInstantQuery(query, end));\n      } else {\n        observable = from(this.performTimeSeriesQuery(query, query.start, query.end));\n      }\n\n      return observable.pipe(\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = this.processResult(response, query, target, queries.length);\n          return data;\n        })\n      );\n    });\n\n    return forkJoin(observables).pipe(\n      map((results: Array<Array<TableModel | TimeSeries>>) => {\n        const data = results.reduce((result, current) => {\n          return [...result, ...current];\n        }, []);\n        return {\n          data,\n          key: requestId,\n          state: LoadingState.Done,\n        };\n      })\n    );\n  }\n\n  createQuery(target: PromQuery, options: DataQueryRequest<PromQuery>, start: number, end: number) {\n    const query: PromQueryRequest = {\n      hinting: target.hinting,\n      instant: target.instant,\n      step: 0,\n      expr: '',\n      requestId: target.requestId,\n      refId: target.refId,\n      start: 0,\n      end: 0,\n    };\n    const range = Math.ceil(end - start);\n\n    // options.interval is the dynamically calculated interval\n    let interval = kbn.interval_to_seconds(options.interval);\n    // Minimum interval (\"Min step\"), if specified for the query or datasource. or same as interval otherwise\n    const minInterval = kbn.interval_to_seconds(\n      templateSrv.replace(target.interval, options.scopedVars) || options.interval\n    );\n    const intervalFactor = target.intervalFactor || 1;\n    // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\n    let scopedVars = { ...options.scopedVars, ...this.getRangeScopedVars(options.range) };\n    // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\n    if (interval !== adjustedInterval) {\n      interval = adjustedInterval;\n      scopedVars = Object.assign({}, options.scopedVars, {\n        __interval: { text: interval + 's', value: interval + 's' },\n        __interval_ms: { text: interval * 1000, value: interval * 1000 },\n        ...this.getRangeScopedVars(options.range),\n      });\n    }\n    query.step = interval;\n\n    let expr = target.expr;\n\n    // Apply adhoc filters\n    const adhocFilters = templateSrv.getAdhocFilters(this.name);\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = prometheusRegularEscape(value);\n      }\n      return addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    // Only replace vars in expression after having (possibly) updated interval vars\n    query.expr = templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr);\n\n    // Align query interval with step to allow query caching and to ensure\n    // that about-same-time query results look the same.\n    const adjusted = alignRange(\n      start,\n      end,\n      query.step,\n      getTimeSrv()\n        .timeRange()\n        .to.utcOffset() * 60\n    );\n    query.start = adjusted.start;\n    query.end = adjusted.end;\n    this._addTracingHeaders(query, options);\n\n    return query;\n  }\n\n  adjustInterval(interval: number, minInterval: number, range: number, intervalFactor: number) {\n    // Prometheus will drop queries that might return more than 11000 data points.\n    // Calculate a safe interval as an additional minimum to take into account.\n    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1\n    // If this is the case take the ceil of the value.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n    return Math.max(interval * intervalFactor, minInterval, safeInterval);\n  }\n\n  performTimeSeriesQuery(query: PromQueryRequest, start: number, end: number) {\n    if (start > end) {\n      throw { message: 'Invalid time range' };\n    }\n\n    const url = '/api/v1/query_range';\n    const data: any = {\n      query: query.expr,\n      start,\n      end,\n      step: query.step,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).catch((err: any) => {\n      if (err.cancelled) {\n        return err;\n      }\n\n      throw this.handleErrors(err, query);\n    });\n  }\n\n  performInstantQuery(query: PromQueryRequest, time: number) {\n    const url = '/api/v1/query';\n    const data: any = {\n      query: query.expr,\n      time,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).catch((err: any) => {\n      if (err.cancelled) {\n        return err;\n      }\n\n      throw this.handleErrors(err, query);\n    });\n  }\n\n  handleErrors = (err: any, target: PromQuery) => {\n    const error: DataQueryError = {\n      message: (err && err.statusText) || 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  async performSuggestQuery(query: string, cache = false) {\n    if (cache && this.metricsNameCache?.expire > Date.now()) {\n      return this.metricsNameCache.data.filter((metricName: any) => metricName.indexOf(query) !== 1);\n    }\n\n    const response: PromLabelQueryResponse = await this.metadataRequest('/api/v1/label/__name__/values');\n    this.metricsNameCache = {\n      data: response.data.data,\n      expire: Date.now() + 60 * 1000,\n    };\n\n    return response.data.data.filter(metricName => metricName.indexOf(query) !== 1);\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const scopedVars = {\n      __interval: { text: this.interval, value: this.interval },\n      __interval_ms: { text: kbn.interval_to_ms(this.interval), value: kbn.interval_to_ms(this.interval) },\n      ...this.getRangeScopedVars(getTimeSrv().timeRange()),\n    };\n    const interpolated = templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\n    return metricFindQuery.process();\n  }\n\n  getRangeScopedVars(range: TimeRange = getTimeSrv().timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  createAnnotationQueryOptions = (options: any): DataQueryRequest<PromQuery> => {\n    const annotation = options.annotation;\n    const interval =\n      annotation && annotation.step && typeof annotation.step === 'string'\n        ? annotation.step\n        : ANNOTATION_QUERY_STEP_DEFAULT;\n    return {\n      ...options,\n      interval,\n    };\n  };\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const annotation = options.annotation;\n    const { expr = '', tagKeys = '', titleFormat = '', textFormat = '' } = annotation;\n\n    if (!expr) {\n      return Promise.resolve([]);\n    }\n\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const queryOptions = this.createAnnotationQueryOptions(options);\n\n    // Unsetting min interval for accurate event resolution\n    const minStep = '1s';\n    const queryModel = {\n      expr,\n      interval: minStep,\n      refId: 'X',\n      requestId: `prom-query-${annotation.name}`,\n    };\n\n    const query = this.createQuery(queryModel, queryOptions, start, end);\n\n    const self = this;\n    const response: PromDataQueryResponse = await this.performTimeSeriesQuery(query, query.start, query.end);\n    const eventList: AnnotationEvent[] = [];\n    const splitKeys = tagKeys.split(',');\n\n    if (response.cancelled) {\n      return [];\n    }\n\n    const step = Math.floor(query.step) * 1000;\n\n    response?.data?.data?.result?.forEach(series => {\n      const tags = Object.entries(series.metric)\n        .filter(([k]) => splitKeys.includes(k))\n        .map(([_k, v]: [string, string]) => v);\n\n      series.values.forEach((value: any[]) => {\n        let timestampValue;\n        // rewrite timeseries to a common format\n        if (annotation.useValueForTime) {\n          timestampValue = Math.floor(parseFloat(value[1]));\n          value[1] = 1;\n        } else {\n          timestampValue = Math.floor(parseFloat(value[0])) * 1000;\n        }\n        value[0] = timestampValue;\n      });\n\n      const activeValues = series.values.filter((value: Record<number, string>) => parseFloat(value[1]) >= 1);\n      const activeValuesTimestamps = activeValues.map((value: number[]) => value[0]);\n\n      // Instead of creating singular annotation for each active event we group events into region if they are less\n      // then `step` apart.\n      let latestEvent: AnnotationEvent = null;\n      activeValuesTimestamps.forEach((timestamp: number) => {\n        // We already have event `open` and we have new event that is inside the `step` so we just update the end.\n        if (latestEvent && latestEvent.timeEnd + step >= timestamp) {\n          latestEvent.timeEnd = timestamp;\n          return;\n        }\n\n        // Event exists but new one is outside of the `step` so we \"finish\" the current region.\n        if (latestEvent) {\n          eventList.push(latestEvent);\n        }\n\n        // We start a new region.\n        latestEvent = {\n          time: timestamp,\n          timeEnd: timestamp,\n          annotation,\n          title: self.resultTransformer.renderTemplate(titleFormat, series.metric),\n          tags,\n          text: self.resultTransformer.renderTemplate(textFormat, series.metric),\n        };\n      });\n      if (latestEvent) {\n        // finish up last point if we have one\n        latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];\n        eventList.push(latestEvent);\n      }\n    });\n\n    return eventList;\n  }\n\n  async getTagKeys() {\n    const result = await this.metadataRequest('/api/v1/labels');\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async getTagValues(options: any = {}) {\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async testDatasource() {\n    const now = new Date().getTime();\n    const query = { expr: '1+1' } as PromQueryRequest;\n    const response = await this.performInstantQuery(query, now / 1000);\n    return response.data.status === 'success'\n      ? { status: 'success', message: 'Data source is working' }\n      : { status: 'error', message: response.error };\n  }\n\n  interpolateVariablesInQueries(queries: PromQuery[], scopedVars: ScopedVars): PromQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          expr: templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  getQueryHints(query: PromQuery, result: any[]) {\n    return getQueryHints(query.expr ?? '', result, this);\n  }\n\n  async loadRules() {\n    try {\n      const res = await this.metadataRequest('/api/v1/rules');\n      const body = res.data || res.json();\n\n      const groups = body?.data?.groups;\n      if (groups) {\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\n      }\n    } catch (e) {\n      console.log('Rules API is experimental. Ignore next error.');\n      console.error(e);\n    }\n  }\n\n  modifyQuery(query: PromQuery, action: any): PromQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = addLabelToQuery(expression, action.key, action.value);\n        break;\n      }\n      case 'ADD_HISTOGRAM_QUANTILE': {\n        expression = `histogram_quantile(0.95, sum(rate(${expression}[5m])) by (le))`;\n        break;\n      }\n      case 'ADD_RATE': {\n        expression = `rate(${expression}[5m])`;\n        break;\n      }\n      case 'ADD_SUM': {\n        expression = `sum(${expression.trim()}) by ($1)`;\n        break;\n      }\n      case 'EXPAND_RULES': {\n        if (action.mapping) {\n          expression = expandRecordingRules(expression, action.mapping);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getPrometheusTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp);\n    }\n\n    return Math.ceil(date.valueOf() / 1000);\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = getTimeSrv().timeRange();\n    return {\n      start: this.getPrometheusTime(range.from, false),\n      end: this.getPrometheusTime(range.to, true),\n    };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    return this.resultTransformer.getOriginalMetricName(labelData);\n  }\n}\n\n/**\n * Align query range to step.\n * Rounds start and end down to a multiple of step.\n * @param start Timestamp marking the beginning of the range.\n * @param end Timestamp marking the end of the range.\n * @param step Interval to align start and end with.\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\n */\nexport function alignRange(\n  start: number,\n  end: number,\n  step: number,\n  utcOffsetSec: number\n): { end: number; start: number } {\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  return {\n    end: alignedEnd,\n    start: alignedStart,\n  };\n}\n\nexport function extractRuleMappingFromGroups(groups: any[]) {\n  return groups.reduce(\n    (mapping, group) =>\n      group.rules\n        .filter((rule: any) => rule.type === 'recording')\n        .reduce(\n          (acc: { [key: string]: string }, rule: any) => ({\n            ...acc,\n            [rule.name]: rule.query,\n          }),\n          mapping\n        ),\n    {}\n  );\n}\n\nexport function prometheusRegularEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/'/g, \"\\\\\\\\'\") : value;\n}\n\nexport function prometheusSpecialRegexEscape(value: any) {\n  return typeof value === 'string'\n    ? prometheusRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'))\n    : value;\n}\n","import _ from 'lodash';\nimport React, { ReactNode } from 'react';\n\nimport { Plugin } from 'slate';\nimport {\n  ButtonCascader,\n  CascaderOption,\n  SlatePrism,\n  TypeaheadInput,\n  TypeaheadOutput,\n  QueryField,\n  BracesPlugin,\n} from '@grafana/ui';\n\nimport Prism from 'prismjs';\n\n// dom also includes Element polyfills\nimport { PromQuery, PromOptions, PromMetricsMetadata } from '../types';\nimport { CancelablePromise, makePromiseCancelable } from 'app/core/utils/CancelablePromise';\nimport { ExploreQueryFieldProps, QueryHint, isDataFrame, toLegacyResponseData, HistoryItem } from '@grafana/data';\nimport { DOMUtil, SuggestionsState } from '@grafana/ui';\nimport { PrometheusDatasource } from '../datasource';\nimport PromQlLanguageProvider from '../language_provider';\n\nconst HISTOGRAM_GROUP = '__histograms__';\nconst PRISM_SYNTAX = 'promql';\nexport const RECORDING_RULES_GROUP = '__recording_rules__';\n\nfunction getChooserText(hasSyntax: boolean, metrics: string[]) {\n  if (!hasSyntax) {\n    return 'Loading metrics...';\n  }\n  if (metrics && metrics.length === 0) {\n    return '(No metrics found)';\n  }\n  return 'Metrics';\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CascaderOption {\n  const option: CascaderOption = { label: metric, value: metric };\n  if (metadata && metadata[metric]) {\n    const { type = '', help } = metadata[metric][0];\n    option.title = [metric, type.toUpperCase(), help].join('\\n');\n  }\n  return option;\n}\n\nexport function groupMetricsByPrefix(metrics: string[], metadata?: PromMetricsMetadata): CascaderOption[] {\n  // Filter out recording rules and insert as first option\n  const ruleRegex = /:\\w+:/;\n  const ruleNames = metrics.filter(metric => ruleRegex.test(metric));\n  const rulesOption = {\n    label: 'Recording rules',\n    value: RECORDING_RULES_GROUP,\n    children: ruleNames\n      .slice()\n      .sort()\n      .map(name => ({ label: name, value: name })),\n  };\n\n  const options = ruleNames.length > 0 ? [rulesOption] : [];\n\n  const delimiter = '_';\n  const metricsOptions = _.chain(metrics)\n    .filter((metric: string) => !ruleRegex.test(metric))\n    .groupBy((metric: string) => metric.split(delimiter)[0])\n    .map(\n      (metricsForPrefix: string[], prefix: string): CascaderOption => {\n        const prefixIsMetric = metricsForPrefix.length === 1 && metricsForPrefix[0] === prefix;\n        const children = prefixIsMetric ? [] : metricsForPrefix.sort().map(m => addMetricsMetadata(m, metadata));\n        return {\n          children,\n          label: prefix,\n          value: prefix,\n        };\n      }\n    )\n    .sortBy('label')\n    .value();\n\n  return [...options, ...metricsOptions];\n}\n\nexport function willApplySuggestion(suggestion: string, { typeaheadContext, typeaheadText }: SuggestionsState): string {\n  // Modify suggestion based on context\n  switch (typeaheadContext) {\n    case 'context-labels': {\n      const nextChar = DOMUtil.getNextCharacter();\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\n        suggestion += '=';\n      }\n      break;\n    }\n\n    case 'context-label-values': {\n      // Always add quotes and remove existing ones instead\n      if (!typeaheadText.match(/^(!?=~?\"|\")/)) {\n        suggestion = `\"${suggestion}`;\n      }\n      if (DOMUtil.getNextCharacter() !== '\"') {\n        suggestion = `${suggestion}\"`;\n      }\n      break;\n    }\n\n    default:\n  }\n  return suggestion;\n}\n\ninterface PromQueryFieldProps extends ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions> {\n  history: Array<HistoryItem<PromQuery>>;\n  ExtraFieldElement?: ReactNode;\n}\n\ninterface PromQueryFieldState {\n  metricsOptions: any[];\n  syntaxLoaded: boolean;\n  hint: QueryHint | null;\n}\n\nclass PromQueryField extends React.PureComponent<PromQueryFieldProps, PromQueryFieldState> {\n  plugins: Plugin[];\n  languageProvider: PromQlLanguageProvider;\n  languageProviderInitializationPromise: CancelablePromise<any>;\n\n  constructor(props: PromQueryFieldProps, context: React.Context<any>) {\n    super(props, context);\n\n    if (props.datasource.languageProvider) {\n      this.languageProvider = props.datasource.languageProvider;\n    }\n\n    this.plugins = [\n      BracesPlugin(),\n      SlatePrism({\n        onlyIn: (node: any) => node.type === 'code_block',\n        getSyntax: (node: any) => 'promql',\n      }),\n    ];\n\n    this.state = {\n      metricsOptions: [],\n      syntaxLoaded: false,\n      hint: null,\n    };\n  }\n\n  componentDidMount() {\n    if (this.languageProvider) {\n      Prism.languages[PRISM_SYNTAX] = this.languageProvider.syntax;\n      this.refreshMetrics(makePromiseCancelable(this.languageProvider.start()));\n    }\n    this.refreshHint();\n  }\n\n  componentWillUnmount() {\n    if (this.languageProviderInitializationPromise) {\n      this.languageProviderInitializationPromise.cancel();\n    }\n  }\n\n  componentDidUpdate(prevProps: PromQueryFieldProps) {\n    const { data } = this.props;\n\n    if (data && prevProps.data && prevProps.data.series !== data.series) {\n      this.refreshHint();\n    }\n  }\n\n  refreshHint = () => {\n    const { datasource, query, data } = this.props;\n\n    if (!data || data.series.length === 0) {\n      this.setState({ hint: null });\n      return;\n    }\n\n    const result = isDataFrame(data.series[0]) ? data.series.map(toLegacyResponseData) : data.series;\n    const hints = datasource.getQueryHints(query, result);\n    const hint = hints && hints.length > 0 ? hints[0] : null;\n    this.setState({ hint });\n  };\n\n  refreshMetrics = (cancelablePromise: CancelablePromise<any>) => {\n    this.languageProviderInitializationPromise = cancelablePromise;\n    this.languageProviderInitializationPromise.promise\n      .then(remaining => {\n        remaining.map((task: Promise<any>) => task.then(this.onUpdateLanguage).catch(() => {}));\n      })\n      .then(() => this.onUpdateLanguage())\n      .catch(err => {\n        if (!err.isCanceled) {\n          throw err;\n        }\n      });\n  };\n\n  onChangeMetrics = (values: string[], selectedOptions: CascaderOption[]) => {\n    let query;\n    if (selectedOptions.length === 1) {\n      if (selectedOptions[0].children.length === 0) {\n        query = selectedOptions[0].value;\n      } else {\n        // Ignore click on group\n        return;\n      }\n    } else {\n      const prefix = selectedOptions[0].value;\n      const metric = selectedOptions[1].value;\n      if (prefix === HISTOGRAM_GROUP) {\n        query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;\n      } else {\n        query = metric;\n      }\n    }\n    this.onChangeQuery(query, true);\n  };\n\n  onChangeQuery = (value: string, override?: boolean) => {\n    // Send text change to parent\n    const { query, onChange, onRunQuery } = this.props;\n    if (onChange) {\n      const nextQuery: PromQuery = { ...query, expr: value };\n      onChange(nextQuery);\n\n      if (override && onRunQuery) {\n        onRunQuery();\n      }\n    }\n  };\n\n  onClickHintFix = () => {\n    const { datasource, query, onChange, onRunQuery } = this.props;\n    const { hint } = this.state;\n\n    onChange(datasource.modifyQuery(query, hint.fix.action));\n    onRunQuery();\n  };\n\n  onUpdateLanguage = () => {\n    const {\n      histogramMetrics,\n      metrics,\n      metricsMetadata,\n      lookupsDisabled,\n      lookupMetricsThreshold,\n    } = this.languageProvider;\n    if (!metrics) {\n      return;\n    }\n\n    // Build metrics tree\n    const metricsByPrefix = groupMetricsByPrefix(metrics, metricsMetadata);\n    const histogramOptions = histogramMetrics.map((hm: any) => ({ label: hm, value: hm }));\n    const metricsOptions =\n      histogramMetrics.length > 0\n        ? [\n            { label: 'Histograms', value: HISTOGRAM_GROUP, children: histogramOptions, isLeaf: false },\n            ...metricsByPrefix,\n          ]\n        : metricsByPrefix;\n\n    // Hint for big disabled lookups\n    let hint: QueryHint;\n    if (lookupsDisabled) {\n      hint = {\n        label: `Dynamic label lookup is disabled for datasources with more than ${lookupMetricsThreshold} metrics.`,\n        type: 'INFO',\n      };\n    }\n\n    this.setState({ hint, metricsOptions, syntaxLoaded: true });\n  };\n\n  onTypeahead = async (typeahead: TypeaheadInput): Promise<TypeaheadOutput> => {\n    if (!this.languageProvider) {\n      return { suggestions: [] };\n    }\n\n    const { history } = this.props;\n    const { prefix, text, value, wrapperClasses, labelKey } = typeahead;\n\n    const result = await this.languageProvider.provideCompletionItems(\n      { text, value, prefix, wrapperClasses, labelKey },\n      { history }\n    );\n\n    // console.log('handleTypeahead', wrapperClasses, text, prefix, labelKey, result.context);\n\n    return result;\n  };\n\n  render() {\n    const { query, ExtraFieldElement } = this.props;\n    const { metricsOptions, syntaxLoaded, hint } = this.state;\n    const cleanText = this.languageProvider ? this.languageProvider.cleanText : undefined;\n    const chooserText = getChooserText(syntaxLoaded, metricsOptions);\n    const buttonDisabled = !(syntaxLoaded && metricsOptions && metricsOptions.length > 0);\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--nowrap flex-grow-1\">\n          <div className=\"gf-form flex-shrink-0\">\n            <ButtonCascader options={metricsOptions} disabled={buttonDisabled} onChange={this.onChangeMetrics}>\n              {chooserText}\n            </ButtonCascader>\n          </div>\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\n            <QueryField\n              additionalPlugins={this.plugins}\n              cleanText={cleanText}\n              query={query.expr}\n              onTypeahead={this.onTypeahead}\n              onWillApplySuggestion={willApplySuggestion}\n              onBlur={this.props.onBlur}\n              onChange={this.onChangeQuery}\n              onRunQuery={this.props.onRunQuery}\n              placeholder=\"Enter a PromQL query\"\n              portalOrigin=\"prometheus\"\n              syntaxLoaded={syntaxLoaded}\n            />\n          </div>\n          {ExtraFieldElement}\n        </div>\n        {hint ? (\n          <div className=\"query-row-break\">\n            <div className=\"prom-query-field-info text-warning\">\n              {hint.label}{' '}\n              {hint.fix ? (\n                <a className=\"text-link muted\" onClick={this.onClickHintFix}>\n                  {hint.fix.label}\n                </a>\n              ) : null}\n            </div>\n          </div>\n        ) : null}\n      </>\n    );\n  }\n}\n\nexport default PromQueryField;\n","import _ from 'lodash';\nimport React, { Component } from 'react';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery } from '../types';\nimport { DataQueryRequest, PanelData } from '@grafana/data';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\n\ninterface Props {\n  datasource: PrometheusDatasource;\n  query: PromQuery;\n  panelData: PanelData;\n}\n\ninterface State {\n  href: string;\n}\n\nexport default class PromLink extends Component<Props, State> {\n  state: State = { href: null };\n  async componentDidUpdate(prevProps: Props) {\n    if (prevProps.panelData !== this.props.panelData && this.props.panelData.request) {\n      const href = await this.getExternalLink();\n      this.setState({ href });\n    }\n  }\n\n  async getExternalLink(): Promise<string> {\n    const { query, panelData } = this.props;\n    const target = panelData.request.targets.length > 0 ? panelData.request.targets[0] : ({ datasource: null } as any);\n    const datasourceName = target.datasource;\n    const datasource: PrometheusDatasource = datasourceName\n      ? (((await getDatasourceSrv().get(datasourceName)) as any) as PrometheusDatasource)\n      : (this.props.datasource as PrometheusDatasource);\n\n    const range = panelData.request.range;\n    const start = datasource.getPrometheusTime(range.from, false);\n    const end = datasource.getPrometheusTime(range.to, true);\n    const rangeDiff = Math.ceil(end - start);\n    const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');\n\n    const options = {\n      interval: panelData.request.interval,\n    } as DataQueryRequest<PromQuery>;\n    const queryOptions = datasource.createQuery(query, options, start, end);\n    const expr = {\n      'g0.expr': queryOptions.expr,\n      'g0.range_input': rangeDiff + 's',\n      'g0.end_input': endTime,\n      'g0.step_input': queryOptions.step,\n      'g0.tab': 0,\n    };\n\n    const args = _.map(expr, (v: string, k: string) => {\n      return k + '=' + encodeURIComponent(v);\n    }).join('&');\n    return `${datasource.directUrl}/graph?${args}`;\n  }\n\n  render() {\n    const { href } = this.state;\n    return (\n      <a href={href} target=\"_blank\" rel=\"noopener\">\n        <i className=\"fa fa-share-square-o\" /> Prometheus\n      </a>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React, { PureComponent } from 'react';\n\n// Types\nimport { FormLabel, Select, Switch } from '@grafana/ui';\nimport { SelectableValue, QueryEditorProps } from '@grafana/data';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport PromLink from './PromLink';\nexport type Props = QueryEditorProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nconst FORMAT_OPTIONS: Array<SelectableValue<string>> = [\n  { label: 'Time series', value: 'time_series' },\n  { label: 'Table', value: 'table' },\n  { label: 'Heatmap', value: 'heatmap' },\n];\n\nconst INTERVAL_FACTOR_OPTIONS: Array<SelectableValue<number>> = _.map([1, 2, 3, 4, 5, 10], (value: number) => ({\n  value,\n  label: '1/' + value,\n}));\n\ninterface State {\n  legendFormat: string;\n  formatOption: SelectableValue<string>;\n  interval: string;\n  intervalFactorOption: SelectableValue<number>;\n  instant: boolean;\n}\n\nexport class PromQueryEditor extends PureComponent<Props, State> {\n  // Query target to be modified and used for queries\n  query: PromQuery;\n\n  constructor(props: Props) {\n    super(props);\n    // Use default query to prevent undefined input values\n    const defaultQuery: Partial<PromQuery> = { expr: '', legendFormat: '', interval: '' };\n    const query = Object.assign({}, defaultQuery, props.query);\n    this.query = query;\n    // Query target properties that are fully controlled inputs\n    this.state = {\n      // Fully controlled text inputs\n      interval: query.interval,\n      legendFormat: query.legendFormat,\n      // Select options\n      formatOption: FORMAT_OPTIONS.find(option => option.value === query.format) || FORMAT_OPTIONS[0],\n      intervalFactorOption:\n        INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],\n      // Switch options\n      instant: Boolean(query.instant),\n    };\n  }\n\n  onFieldChange = (query: PromQuery, override?: any) => {\n    this.query.expr = query.expr;\n  };\n\n  onFormatChange = (option: SelectableValue<string>) => {\n    this.query.format = option.value;\n    this.setState({ formatOption: option }, this.onRunQuery);\n  };\n\n  onInstantChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const instant = e.target.checked;\n    this.query.instant = instant;\n    this.setState({ instant }, this.onRunQuery);\n  };\n\n  onIntervalChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const interval = e.currentTarget.value;\n    this.query.interval = interval;\n    this.setState({ interval });\n  };\n\n  onIntervalFactorChange = (option: SelectableValue<number>) => {\n    this.query.intervalFactor = option.value;\n    this.setState({ intervalFactorOption: option }, this.onRunQuery);\n  };\n\n  onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const legendFormat = e.currentTarget.value;\n    this.query.legendFormat = legendFormat;\n    this.setState({ legendFormat });\n  };\n\n  onRunQuery = () => {\n    const { query } = this;\n    this.props.onChange(query);\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { datasource, query, data } = this.props;\n    const { formatOption, instant, interval, intervalFactorOption, legendFormat } = this.state;\n\n    return (\n      <div>\n        <PromQueryField\n          datasource={datasource}\n          query={query}\n          onRunQuery={this.onRunQuery}\n          onChange={this.onFieldChange}\n          history={[]}\n          data={data}\n        />\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormLabel\n              width={7}\n              tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname.\"\n            >\n              Legend\n            </FormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input\"\n              placeholder=\"legend format\"\n              value={legendFormat}\n              onChange={this.onLegendChange}\n              onBlur={this.onRunQuery}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <FormLabel\n              width={7}\n              tooltip={\n                <>\n                  An additional lower limit for the step parameter of the Prometheus query and for the{' '}\n                  <code>$__interval</code> variable. The limit is absolute and not modified by the \"Resolution\" setting.\n                </>\n              }\n            >\n              Min step\n            </FormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input width-8\"\n              placeholder={interval}\n              onChange={this.onIntervalChange}\n              onBlur={this.onRunQuery}\n              value={interval}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label\">Resolution</div>\n            <Select\n              isSearchable={false}\n              options={INTERVAL_FACTOR_OPTIONS}\n              onChange={this.onIntervalFactorChange}\n              value={intervalFactorOption}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label\">Format</div>\n            <Select isSearchable={false} options={FORMAT_OPTIONS} onChange={this.onFormatChange} value={formatOption} />\n            <Switch label=\"Instant\" checked={instant} onChange={this.onInstantChange} />\n\n            <FormLabel width={10} tooltip=\"Link to Graph in Prometheus\">\n              <PromLink\n                datasource={datasource}\n                query={this.query} // Use modified query\n                panelData={data}\n              />\n            </FormLabel>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/data';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Request Rate',\n    expression: 'rate(http_request_total[5m])',\n    label:\n      'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.',\n  },\n  {\n    title: '95th Percentile of Request Latencies',\n    expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',\n    label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.',\n  },\n  {\n    title: 'Alerts Firing',\n    expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate=\"firing\"}[24h])) by (alertname))',\n    label: 'Sums up the alerts that have been firing over the last 24 hours.',\n  },\n  {\n    title: 'Step',\n    label:\n      'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.',\n  },\n];\n\nexport default (props: ExploreStartPageProps) => (\n  <div>\n    <h2>PromQL Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item, index) => (\n      <div className=\"cheat-sheet-item\" key={index}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        {item.expression ? (\n          <div\n            className=\"cheat-sheet-item__example\"\n            onClick={e => props.onClickExample({ refId: 'A', expr: item.expression } as DataQuery)}\n          >\n            <code>{item.expression}</code>\n          </div>\n        ) : null}\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { FormLabel } from '@grafana/ui';\n\nexport interface PromExploreExtraFieldProps {\n  label: string;\n  onChangeFunc: (e: React.SyntheticEvent<HTMLInputElement>) => void;\n  onKeyDownFunc: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n  value: string;\n  hasTooltip?: boolean;\n  tooltipContent?: string;\n}\n\nexport function PromExploreExtraField(props: PromExploreExtraFieldProps) {\n  const { label, onChangeFunc, onKeyDownFunc, value, hasTooltip, tooltipContent } = props;\n\n  return (\n    <div className=\"gf-form-inline explore-input--ml\">\n      <div className=\"gf-form\">\n        <FormLabel width={5} tooltip={hasTooltip ? tooltipContent : null}>\n          {label}\n        </FormLabel>\n        <input\n          type={'text'}\n          className=\"gf-form-input width-4\"\n          placeholder={'auto'}\n          onChange={onChangeFunc}\n          onKeyDown={onKeyDownFunc}\n          value={value}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default memo(PromExploreExtraField);\n","import React, { memo } from 'react';\n\n// Types\nimport { ExploreQueryFieldProps } from '@grafana/data';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport { PromExploreExtraField } from './PromExploreExtraField';\n\nexport type Props = ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nexport function PromExploreQueryEditor(props: Props) {\n  const { query, data, datasource, history, onChange, onRunQuery } = props;\n\n  function onChangeQueryStep(value: string) {\n    const { query, onChange } = props;\n    const nextQuery = { ...query, interval: value };\n    onChange(nextQuery);\n  }\n\n  function onStepChange(e: React.SyntheticEvent<HTMLInputElement>) {\n    if (e.currentTarget.value !== query.interval) {\n      onChangeQueryStep(e.currentTarget.value);\n    }\n  }\n\n  function onReturnKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter') {\n      onRunQuery();\n    }\n  }\n\n  return (\n    <PromQueryField\n      datasource={datasource}\n      query={query}\n      onRunQuery={onRunQuery}\n      onChange={onChange}\n      history={history}\n      data={data}\n      ExtraFieldElement={\n        <PromExploreExtraField\n          label={'Step'}\n          onChangeFunc={onStepChange}\n          onKeyDownFunc={onReturnKeyDown}\n          value={query.interval || ''}\n          hasTooltip={true}\n          tooltipContent={'Needs to be a valid time unit string, for example 5s, 1m, 3h, 1d, 1y'}\n        />\n      }\n    />\n  );\n}\n\nexport default memo(PromExploreQueryEditor);\n","import React, { SyntheticEvent } from 'react';\nimport { EventsWithValidation, FormField, FormLabel, Input, regexValidation, Select } from '@grafana/ui';\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\nimport { PromOptions } from '../types';\n\nconst httpOptions = [\n  { value: 'GET', label: 'GET' },\n  { value: 'POST', label: 'POST' },\n];\n\ntype Props = {\n  value: DataSourceSettings<PromOptions>;\n  onChange: (value: DataSourceSettings<PromOptions>) => void;\n};\n\nexport const PromSettings = (props: Props) => {\n  const { value, onChange } = props;\n\n  return (\n    <>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Scrape interval\"\n              labelWidth={13}\n              placeholder=\"15s\"\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={value.jsonData.timeInterval}\n                  spellCheck={false}\n                  onChange={onChangeHandler('timeInterval', value, onChange)}\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Query timeout\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={value.jsonData.queryTimeout}\n                  onChange={onChangeHandler('queryTimeout', value, onChange)}\n                  spellCheck={false}\n                  placeholder=\"60s\"\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set the Prometheus query timeout.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form\">\n          <FormLabel\n            width={13}\n            tooltip=\"Specify the HTTP Method to query Prometheus. (POST is only available in Prometheus >= v2.1.0)\"\n          >\n            HTTP Method\n          </FormLabel>\n          <Select\n            options={httpOptions}\n            value={httpOptions.find(o => o.value === value.jsonData.httpMethod)}\n            onChange={onChangeHandler('httpMethod', value, onChange)}\n            width={7}\n          />\n        </div>\n      </div>\n      <h3 className=\"page-heading\">Misc</h3>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <FormField\n              label=\"Custom query parameters\"\n              labelWidth={14}\n              tooltip=\"Add Custom parameters to Prometheus or Thanos queries.\"\n              inputEl={\n                <Input\n                  className=\"width-25\"\n                  value={value.jsonData.customQueryParameters}\n                  onChange={onChangeHandler('customQueryParameters', value, onChange)}\n                  spellCheck={false}\n                  placeholder=\"Example: max_source_resolution=5m&timeout=10\"\n                />\n              }\n            />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport const promSettingsValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    regexValidation(\n      /^$|^\\d+(ms|[Mwdhmsy])$/,\n      'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\n    ),\n  ],\n};\n\nexport const getValueFromEventItem = (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  if (!eventItem) {\n    return '';\n  }\n\n  if (eventItem.hasOwnProperty('currentTarget')) {\n    return eventItem.currentTarget.value;\n  }\n\n  return (eventItem as SelectableValue<string>).value;\n};\n\nconst onChangeHandler = (key: keyof PromOptions, value: Props['value'], onChange: Props['onChange']) => (\n  eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: getValueFromEventItem(eventItem),\n    },\n  });\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ANNOTATION_QUERY_STEP_DEFAULT, PrometheusDatasource } from './datasource';\n\nimport { PromQueryEditor } from './components/PromQueryEditor';\nimport PromCheatSheet from './components/PromCheatSheet';\nimport PromExploreQueryEditor from './components/PromExploreQueryEditor';\n\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nclass PrometheusAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  stepDefaultValuePlaceholder = ANNOTATION_QUERY_STEP_DEFAULT;\n}\n\nexport const plugin = new DataSourcePlugin(PrometheusDatasource)\n  .setQueryEditor(PromQueryEditor)\n  .setConfigEditor(ConfigEditor)\n  .setExploreMetricsQueryField(PromExploreQueryEditor)\n  .setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl)\n  .setExploreStartPage(PromCheatSheet);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { PromSettings } from './PromSettings';\nimport { PromOptions } from '../types';\n\nexport type Props = DataSourcePluginOptionsEditorProps<PromOptions>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9090\"\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n      />\n\n      <PromSettings value={options} onChange={onOptionsChange} />\n    </>\n  );\n};\n","// https://github.com/facebook/react/issues/5465\n\nexport interface CancelablePromise<T> {\n  promise: Promise<T>;\n  cancel: () => void;\n}\n\nexport const makePromiseCancelable = <T>(promise: Promise<T>): CancelablePromise<T> => {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    promise.then(val => (hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)));\n    promise.catch(error => (hasCanceled_ ? reject({ isCanceled: true }) : reject(error)));\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};\n"],"sourceRoot":""}